#+TITLE: 2013-FA-CS-336-LA-03-AndyS-SheaN
#+AUTHOR: Andrew Schwartzmeyer, Shea Newt
#+OPTIONS: toc:nil num:nil

| Year and Semester: | 2013 FALL                                   |
| Course Number:     | CS-336                                      |
| Course Title:      | Intro. to Information Assurance             |
| Work Number:       | LA-03                                       |
| Work Name:         | SQL Injection Attack Lab - Using Collabtive |
| Work Version:      | Version 1                                   |
| Long Date:         | Tuesday, 29 October 2013                    |
| Author Name:       | Andrew Schwartzmeyer, Shea Newt             |

* Abstract

* Problem and Background

* Problem Detail

* Tasks

** Turn off PHP Magic Quote Countermeasure

Prior to version 5.3.0, PHP enabled a countermeasure to SQL injection
attacks called "Magic Quote". To disable this, we simply edit the PHP
configuration file =/etc/php5/apache2/php.ini= and change the line
=magic quotes gpc = On= to =magic quotes gpc = Off=; finally, to make
these changes live, we execute the command =sudo service apache2
restart=. (Du 3)

** Lab Task 1: Exploiting the login prompt

The Collabtive web app on our virtual machine implements its user
authentication using the file
=/var/www/SQL/Collabtive/include/class.user.php=, which executes a SQL
query using the specified user and password parameters to determine if
a record exists which matches the pair of inputs. If so, it
authenticates the user. Unfortunately, the function looks like this:

#+BEGIN_SRC php
      function login($user, $pass)
      {
          if (!$user)
          {
              return false;
          }
  
  //modified for SQL Lab
          //$user = mysql_real_escape_string($user);
          //$pass = mysql_real_escape_string($pass);
          $pass = sha1($pass);
  
          $sel1 = mysql_query("SELECT ID,name,locale,lastlogin,gender FROM user WHERE (name =  '$user' OR email = '$user') AND pass = '$pass'");
          $chk = mysql_fetch_array($sel1);
          if ($chk["ID"] != "")
          {
              // New user session object and cookie creation code
              // removed for brevity
              return true;
          }
          else
          {
              return false;
          }
      }
#+END_SRC

Note specifically that the authors of the lab disabled the input
sanitization of the variables =$user= and =$pass= by commenting out
the exeuction of =mysql_real_escape_string()= on them. This leaves us
with the following SQL query executed by the PHP script, where both
=$user= and =$pass= are susceptible to an injection attack:

#+BEGIN_SRC sql
  SELECT ID,name,locale,lastlogin,gender FROM user WHERE (name = '$user'
  OR email = '$user') AND pass = '$pass'"
#+END_SRC

*** Task 1.1: Can you log into another person’s account without knowing the correct password?

We sure can! The key is being able to inject whatever SQL code we want
into the =$user= parameter, which is ahead of the =AND= conditional
password check in the =WHERE= clause. Hence, entering =​admin'); # '​=
into the user field bypasses the password check and logs us in. This
is because we complete the =name= predicate with the user =admin=
followed by a =​'​= followed by a =)=, which matches the =​'​= and =(=
before them in the query, then add a =;= to complete the query,
followed by a =#=, which comments out the rest of the query in the
original statement from the PHP code, and finally followed with a =​'​=
to match the trailing one surrounding our user input. We can enter
anything (or nothing) for the password, and be logged in as the
=admin= user, because the SQL code that was supposed to check the
password was disabled by our attack.

*** Task 1.2: Can you find a way to modify the database (still using the above SQL query?)

No, we were not able to modify the database through this particular
query. We tried injecting variations of =​admin'); UPDATE user SET
pass=​'pass' WHERE name=​'admin'; # '​=, where we added an =UPDATE= or
=DELETE FROM= query after the first, completed with a =;=, and still
followed by a "#", thus splitting the original query into two separate
queries. However, the MySQL database in particular does not allow
query stacking in the =mysql_query()= function. When we attempt to
execute two queries sequentially in the same =mysql_query()= function
call, MySQL itself causes the call, and therefore our attack, to
fail. Note that this is not necessarily true of other PHP database
extensions, which may or may not permit such query stacking. Since the
vulnerable query begins with a =SELECT= statement, and the attack is
only injectable further down in the query's string, MySQL's defense
mechanism limits us to only exploiting the =SELECT= query.

** Lab Task 2: SQL Injection on =UPDATE= Statements

The Collabtive web app also has a SQL injection vulnerability
elsewhere in the =/var/www/SQL/Collabtive/include/class.user.php=
file. On the "My Account" page, there is an "Edit" link that presents
the user with a form for editting their profile's information. This
form calls the following function:

#+BEGIN_SRC php
   function edit($id, $name, $realname, $email, $tel1, $tel2, $company, $zip, $gender, $url, $address1, $address2, $state, $country, $tags, $locale, $avatar = "", $rate = 0.0)
   {
        $name = mysql_real_escape_string($name);
        $realname = mysql_real_escape_string($realname);

//modified for SQL Lab
		//$company = mysql_real_escape_string($company);
        $email = mysql_real_escape_string($email);

// further escaped parameters removed for brevity...

        $rate = (float) $rate;
        $id = (int) $id;

        if ($avatar != "")
        {
// same query as below plus setting of avatar; removed for brevity...
        }
        else
        {
            $upd = mysql_query("UPDATE user SET name='$name',email='$email', tel1='$tel1', tel2='$tel2', company='$company',zip='$zip',gender='$gender',url='$url',adress='$address1',adress2='$address2',state='$state',country='$country',tags='$tags',locale='$locale',rate='$rate' WHERE ID = $id");
        }
        if ($upd)
        {
            $this->mylog->add($name, 'user', 2, 0);
            return true;
        }
        else
        {
            return false;
        }
    }
#+END_SRC

Note that the variable =$company=, which had previously been escaped,
has been modified by this lab's authors so that it is susceptible to
an injection attack, as it is no longer escaped.

* Answers

* Code

* References

Du, Wenliang. 2006-2013. "SQL Injection Attack Lab - Using
Collabtive". http://www.cis.syr.edu/~wedu/seed/Labs/Web/SQL_Injection_Collabtive/
